#!/usr/bin/env python3

import argparse
import sys
import curses
import random
import textwrap

"""
Uses curses to display questions when run as a script.
"""


class FalseAnswerProducer:
    """
    Obtains false answers via randomly selection from a question pool.
    """

    def __init__(self, question_pool, no_choices=3):
        self.question_pool = question_pool
        self.no_choices = no_choices
        # Just to be safe
        if not self.question_pool:
            self.question_pool = {"Your question Here": "Your answer here"}

    def get_random_answers(self, chosen_question):
        """
        Get iterable of answers which consists of the answer of the chosen
        question and (no_choices - 1) randomly chosen incorrect answers.
        """
        # Ensure random.sample works
        self.no_choices = min(self.no_choices, len(self.question_pool))
        exclusion_set = set([self.question_pool[chosen_question]])
        choice_set = set(self.question_pool.values()) - exclusion_set
        # random choice without replacement
        choices = random.sample(choice_set, self.no_choices - 1)
        correct_answer = self.question_pool[chosen_question]
        # Insert correct answer into random place in list
        choices.insert(random.randint(0, self.no_choices - 1), correct_answer)
        return choices


def main():
    # Here we define our command line arguments
    parser = argparse.ArgumentParser()
    # Dictates if user wants a set number, or infinite questions
    question_group = parser.add_mutually_exclusive_group()

    # positional argument: infile
    # description: name of file to read questions from
    parser.add_argument(
        "infile",
        nargs="?",
        type=argparse.FileType("r"),
        help="name of file to read questions from, defaults to stdin",
        default=sys.stdin,
    )
    # optional argument: delimiter
    # description: describes delimiter in input lines which divides question
    #              and answer
    parser.add_argument(
        "-d",
        "--delimiter",
        help="delimiter in input lines which divide the question and answer",
        default=",",
    )
    # optional argument: precede
    # description: text to precede all questions
    parser.add_argument(
        "-p",
        "--precede",
        help="precede all question strings with this string",
        default="",
    )
    # optional argument: choices
    # description: number of answer choices for a question
    parser.add_argument(
        "-c",
        "--choices",
        type=int,
        help="number of answers to choose from per question, default is 3",
        default=3,
    )
    # optional argument: questions
    # description: number of questions to ask
    question_group.add_argument(
        "-n", "--questions", type=int, help="number of questions to answer", default=10
    )
    # Optional argument: endless
    # description: tells program to keep asking questions until terminated
    question_group.add_argument(
        "-e",
        "--endless",
        help="keep asking questions until program is terminated",
        action="store_true",
    )
    args = parser.parse_args()

    file_lines = args.infile.readlines()
    delim = args.delimiter
    # Split file lines by delimiter
    question_pool = dict(map(lambda string: string.split(delim), file_lines))
    # Create the correct question generator object
    if args.endless:
        question_gen = inf_question_generator(question_pool)
    else:
        question_gen = question_generator(question_pool, args.questions)
    # Create a false answer generator object
    false_answer_producer = FalseAnswerProducer(question_pool, args.choices)

    # wrapper() calls cbreak() and noecho() so we don't have to
    curses.wrapper(
        lambda stdscr: questions_loop(
            stdscr, question_gen, false_answer_producer, args.precede
        )
    )


def questions_loop(stdscr, question_gen, answer_producer, preceding_str):
    # Sets background colour to black, curses.wrapper resets this on termination
    curses.init_color(0, 0, 0, 0)
    # We must call this to be able to use -1 in the next command
    curses.use_default_colors()
    # Hide the cursor
    curses.curs_set(0)
    # -1 sets the text bg colour to the current bg colour of the terminal
    curses.init_pair(1, curses.COLOR_CYAN, -1)
    curses.init_pair(2, curses.COLOR_BLUE, -1)
    no_correct = 0
    for question_number, (question, correct_answer) in enumerate(question_gen, 1):
        # Print out the question
        stdscr.clear()
        stdscr.addstr(1, 1, "Question " + str(question_number), curses.color_pair(1))
        stdscr.addstr(": " + preceding_str)
        stdscr.addstr(question, curses.color_pair(2))

        # Print out running total of questions answered correctly
        max_y, max_x = stdscr.getmaxyx()
        running_total_str = str(no_correct) + "/" + str(question_number - 1)
        stdscr.addstr(1, max_x - len(running_total_str) - 2, running_total_str)

        # Print out the answers
        answers = answer_producer.get_random_answers(question)
        render_answers(stdscr, answers)
        # Add a cool border
        stdscr.border(0)

        # Curses does nothing until we refresh
        stdscr.refresh()
        # Here we wait for user input and react accordingly
        answer_chosen = False
        while True:
            c = stdscr.getch()
            if c == ord("q"):  # User has quit
                return
            elif answer_chosen:  # User has gone to next question
                answer_chosen = False
                break
            elif chr(c).isdigit() and 1 <= int(chr(c)) <= len(answers):
                stdscr.refresh()
                answer_chosen = True
                # Check answer
                chosen_answer = answers[int(chr(c)) - 1]
                if chosen_answer == correct_answer:
                    render_answers(stdscr, answers, green_ans=int(chr(c)))
                    no_correct += 1
                else:
                    n_correct = answers.index(correct_answer) + 1
                    render_answers(
                        stdscr, answers, green_ans=n_correct, red_ans=int(chr(c))
                    )
                stdscr.border(0)


def render_answers(stdscr, answers, green_ans=-1, red_ans=-1, indent=4):
    curses.init_pair(3, curses.COLOR_GREEN, -1)
    curses.init_pair(4, curses.COLOR_RED, -1)
    current_line = 2
    for number, answer in enumerate(answers, 1):
        current_line += 1  # Ensure we leave a blank line between answers
        # Prepend number to answer
        answer = str(number) + ": " + answer
        text_wrap = textwrap.wrap(
            answer,
            width=stdscr.getmaxyx()[1] - 2,
            initial_indent=" " * indent,
            subsequent_indent=" " * (indent + 3),
        )
        flag = curses.A_BOLD if (number % 2) else curses.A_DIM
        # Green or red text overrides bold and dim effects
        if number == green_ans or number == red_ans:
            flag = curses.color_pair(3 if number == green_ans else 4)
        for line in text_wrap:
            stdscr.addstr(current_line, 0, line, flag)
            current_line += 1


def question_generator(question_pool, no_questions, with_replacement=False):
    """
    Generator which yields <no_questions> questions from the specified 
    question_pool (which should be a valid argument to dict(), ie consist of 
    (question, answer) tuples). If with_replacement is True and
    no_questions > len(questions_pool), the generator will yield len(question_pool)
    items.
    """
    question_pool = dict(question_pool)
    if with_replacement:
        for i in range(no_questions):
            yield random.choice(question_pool.items())
    else:
        no_questions = min(len(question_pool), no_questions)
        chosen_questions = random.sample(question_pool.items(), no_questions)
        for question in chosen_questions:
            yield question


def inf_question_generator(question_pool, error_question=("?", "?")):
    """
    Generator which will yield random questions from a pool continuously.
    If the pool is empty error_question is yielded instead.
    """
    question_pool = dict(question_pool)
    items = list(question_pool.items())
    while True:
        yield random.choice(items) if items else error_question


if __name__ == "__main__":
    main()
