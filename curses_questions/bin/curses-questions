#!/usr/bin/env python3

import argparse
import sys
import curses
import random


"""
Obtains false answers by randomly selecting from a question pool.
"""
class FalseAnswerProducer():

    def __init__(self, question_pool):
        self.question_pool = question_pool
        # Just to be safe
        if (not self.question_pool):
            self.question_pool = {"Your question Here": "Your answer here"}

    def get_random_answers(self, chosen_question, no_choices=3):
        """
        Get iterable of answers which consists of the answer of the chosen
        question and (no_choices - 1) incorrect answers 
        """
        # Ensure random.sample works
        no_choices = min(no_choices, len(self.question_pool))
        exclusion_set = set(self.question_pool[chosen_question])
        choice_set = set(self.question_pool.values()) - exclusion_set
        # random choice without replacement
        choices = random.sample(choice_set, no_choices - 1)
        correct_answer = self.question_pool[chosen_question]
        # Insert correct answer into random place in list
        choices.insert(random.randint(0, no_choices - 1), correct_answer)
        return choices
    

def main():
    # Parse command line arguments
    parser = argparse.ArgumentParser()
    # Dictates if user wants a set number, or infinite questions
    question_group = parser.add_mutually_exclusive_group()

    # positional argument: infile
    # description: name of file to read questions from in lieu of stdin
    parser.add_argument(
        "infile",
        nargs="?",
        type=argparse.FileType('r'),
        help="name of file to read questions from, defaults to stdin",
        default=sys.stdin
    )
    # optional argument: delimiter
    # description: describes delimiter in input lines which divides question
    #              and answer
    parser.add_argument(
        "-d", "--delimiter",
        help="delimiter in input lines which divide the question and answer",
        default=","
    )
    # optional argument: precede
    # description: text to precede all questions
    parser.add_argument(
        "-p", "--precede",
        help="precede all question strings with this string",
        default=""
    )
    # optional argument: questions
    # description: number of questions to ask
    question_group.add_argument(
        "-n", "--questions",
        type=int,
        help="number of questions to answer",
        default=10
    )
    # Optional argument: endless
    # description: tells program to keep asking questions until terminated
    question_group.add_argument(
        "-e", "--endless",
        help="keep asking questions until program is terminated",
        action="store_true"
    )
    args = parser.parse_args()

    file_lines = args.infile.readlines()
    delim = args.delimiter
    # Split file lines by delimiter
    question_pool = dict(map(lambda string: string.split(delim), file_lines))
    # Create the correct question generator object
    if (args.endless):
        question_gen = inf_question_generator(question_pool)
    else:
        question_gen = question_generator(question_pool, args.questions)
    # Create a false answer generator object
    false_answer_producer = FalseAnswerProducer(question_pool)

    # wrapper() calls cbreak() and noecho() so we don't have to
    curses.wrapper(
        lambda stdscr: questions_loop(
            stdscr, question_gen, false_answer_producer, args.precede
        )
    )

    
def questions_loop(stdscr, question_gen, answer_producer, preceding_str):
    for question_number, (question, answer) in enumerate(question_gen, 1):
        stdscr.clear()
        stdscr.addstr(0, 0, "Question " + str(question_number) + ": " + preceding_str + question)
        answers = answer_producer.get_random_answers(question)
        for answer_number, answer in enumerate(answers, 1):
            stdscr.addstr(answer_number, 0, str(answer_number) + ": " + answer)
        # Curses does nothing until we refresh
        stdscr.refresh()
        while True:
            c = stdscr.getch()
            if (c == ord("q")):
                return
            elif (chr(c).isdigit() and 1 <= int(chr(c)) <= answer_number):
                break
            

def question_generator(question_pool, no_questions, with_replacement=False):
    """
    Generator which yields <no_questions> questions from the specified 
    question_pool (which should be a valid argument to dict(), ie consist of 
    (question, answer) tuples). If with_replacement is True and
    no_questions > len(questions_pool), the generator will yield len(question_pool)
    items.
    """
    question_pool = dict(question_pool)
    if (with_replacement):
        for i in range(no_questions):
            yield random.choice(question_pool.items())
    else:
        no_questions = min(len(question_pool), no_questions)
        chosen_questions = random.sample(question_pool.items(), no_questions)
        for question in chosen_questions:
            yield question        

            
def inf_question_generator(question_pool):
    """
    """
    question_pool = dict(question_pool)
    while True:
        yield random.choice(question_pool.items())

            

if __name__ == "__main__":
    main()
